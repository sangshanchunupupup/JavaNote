1、Jvm内存布局

（1）程序计数器：线程私有，可以看作是当前线程所执行的字节码的行号指示器。 分支、 循环、 跳转、 异常处理、 线程恢复等基础功能都需要依赖这个计数器来完成。

（2）虚拟机栈：线程私有，每个方法被执行的时候， Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

（3）本地方法栈：线程私有， 与虚拟机栈所发挥的作用是非常相似的， 其区别只是虚拟机栈为虚拟机执行Java方法 服务， 而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

（4）Java堆：线程共享，存放对象实例，所有的数组和对象实例都在堆上分配。Java堆可以处于物理上不连续的内存空间内，逻辑上应该视为连续的。

（5）方法区：线程共享，存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

（6）运行时常量池：作为方法区的一部分，常量池表，用于存放编译时期生成的各种字面量与符号引用，这部分在类加载后存放到方法区的运行时常量池中。

对象的创建：先检查类的指令参数是否存在于常量池，若没有，对此类进行加载、解析和初始化。



2、对象内存分配方式

指针碰撞：指针向空闲空间方向挪动一段与对象大小相等的距离  

空闲列表：虚拟机维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

3、同步方式的内存分配

CAS：虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性

本地线程分配缓冲：按照线程划分在不同的空间之中进行， 即每个线程在Java堆中预先分配一小块内存

4、对象的内存布局

对象头：

​		运行时数据：哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等  

​		类型指针：对象指向它元数据的指针，如果对象是一个数组，则有数组长度

实例数据：继承父类的、自身定义的

对象填充：对象的起始地址必须是8字节的整数，占位符作用

5、对象访问定位的方式

​		句柄池：Java堆中将可能会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自具体的地址信息

​		直接指针访问：到对象类型数据的指针和对象实例数据存放在一起，不需要多一次间接访问的开销

6、OutOfMemoryError异常

​		Java堆内存异常：堆中实例对象数量过大导致此异常

​		虚拟机栈和本地方法栈溢出

​				1） 如果线程请求的栈深度大于虚拟机所允许的最大深度， 将抛出StackOverflowError异常。无论是由于栈帧太大还是虚拟机		栈容量太小， 当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常。  

​				2） 如果虚拟机的栈内存允许动态扩展， 当扩展栈容量无法申请到足够的内存时， 将抛出OutOfMemoryError异常。

​		方法区和运行时常量池溢出

​		例：String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。如果在常量池中添加大于内存数量的常量，导致常量池内存溢出。



